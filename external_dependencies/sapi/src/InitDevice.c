//=========================================================
// src/InitDevice.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// USER INCLUDES
#include "../inc/InitDevice.h"

// USER PROTOTYPES
// USER FUNCTIONS

// $[Library includes]
#include "em_device.h"
#include "em_emu.h"
#include "em_cmu.h"
#include "em_device.h"
#include "em_chip.h"
#include "em_assert.h"
#include "em_gpio.h"
#include "em_i2c.h"
#include "em_leuart.h"
#include "em_usart.h"
// [Library includes]$

//==============================================================================
// enter_DefaultMode_from_RESET
//==============================================================================
extern void enter_DefaultMode_from_RESET(void) {
   // $[Config Calls]
   CMU_enter_DefaultMode_from_RESET();
   USART0_enter_DefaultMode_from_RESET();
   LEUART0_enter_DefaultMode_from_RESET();
   I2C0_enter_DefaultMode_from_RESET();
   PORTIO_enter_DefaultMode_from_RESET();
   // [Config Calls]$

}

//================================================================================
// HFXO_enter_DefaultMode_from_RESET
//================================================================================
extern void HFXO_enter_DefaultMode_from_RESET(void) {

   // $[HFXO]
   // [HFXO]$

}

//================================================================================
// LFXO_enter_DefaultMode_from_RESET
//================================================================================
extern void LFXO_enter_DefaultMode_from_RESET(void) {

   // $[Use oscillator source]
   // [Use oscillator source]$

   // $[LFXO Boost Percent]
   // [LFXO Boost Percent]$

   // $[REDLFXO Boost]
   // [REDLFXO Boost]$

}

//================================================================================
// CMU_enter_DefaultMode_from_RESET
//================================================================================
extern void CMU_enter_DefaultMode_from_RESET(void) {

   // $[LFXO enable]
   // [LFXO enable]$

   // $[HFXO enable]
   // [HFXO enable]$

   // $[LFACLK Setup]
   // [LFACLK Setup]$

   // $[High Frequency Clock select]
   /* Using HFRCO at 14MHz as high frequency clock, HFCLK */
   CMU_ClockSelectSet(cmuClock_HF, cmuSelect_HFRCO);

   /* Enable peripheral clock */
   CMU_ClockEnable(cmuClock_HFPER, true);

   // [High Frequency Clock select]$

   // $[LF clock tree setup]
   /* Enable LF clocks */
   CMU_ClockEnable(cmuClock_CORELE, true);
   CMU_ClockSelectSet(cmuClock_LFB, cmuSelect_LFRCO);
   // [LF clock tree setup]$

   // $[Peripheral Clock enables]
   /* Enable clock for I2C0 */
   CMU_ClockEnable(cmuClock_I2C0, true);

   /* Enable clock for LEUART0 */
   CMU_ClockEnable(cmuClock_LEUART0, true);

   /* Enable clock for USART0 */
   CMU_ClockEnable(cmuClock_USART0, true);

   /* Enable clock for GPIO by default */
   CMU_ClockEnable(cmuClock_GPIO, true);

   // [Peripheral Clock enables]$

}

//================================================================================
// ADC0_enter_DefaultMode_from_RESET
//================================================================================
extern void ADC0_enter_DefaultMode_from_RESET(void) {

   // $[ADC_Init]
   // [ADC_Init]$

   // $[ADC_InitSingle]
   // [ADC_InitSingle]$

   // $[ADC_InitScan]
   // [ADC_InitScan]$

}

//================================================================================
// ACMP0_enter_DefaultMode_from_RESET
//================================================================================
extern void ACMP0_enter_DefaultMode_from_RESET(void) {

   // $[ACMP Initialization]
   // [ACMP Initialization]$

   // $[ACMP Channel config]
   // [ACMP Channel config]$

}

//================================================================================
// IDAC0_enter_DefaultMode_from_RESET
//================================================================================
extern void IDAC0_enter_DefaultMode_from_RESET(void) {

   // $[IDAC Initialization]
   // [IDAC Initialization]$

   // $[IDAC optional configurations]
   // [IDAC optional configurations]$

   // $[IDAC enable]
   // [IDAC enable]$

}

//================================================================================
// RTC_enter_DefaultMode_from_RESET
//================================================================================
extern void RTC_enter_DefaultMode_from_RESET(void) {

   // $[RTC_Init]
   // [RTC_Init]$

}

//================================================================================
// USART0_enter_DefaultMode_from_RESET
//================================================================================
extern void USART0_enter_DefaultMode_from_RESET(void) {

   // $[USART_InitAsync]
   USART_InitAsync_TypeDef initasync = USART_INITASYNC_DEFAULT;

   initasync.baudrate = 57600;
   initasync.databits = usartDatabits8;
   initasync.parity = usartNoParity;
   initasync.stopbits = usartStopbits1;
   initasync.oversampling = usartOVS16;
#if defined( USART_INPUT_RXPRS ) && defined( USART_CTRL_MVDIS )
   initasync.mvdis = 0;
   initasync.prsRxEnable = 0;
   initasync.prsRxCh = 0;
#endif

   USART_InitAsync(USART0, &initasync);
   // [USART_InitAsync]$

   // $[USART_InitSync]
   // [USART_InitSync]$

   // $[USART_InitPrsTrigger]
   USART_PrsTriggerInit_TypeDef initprs = USART_INITPRSTRIGGER_DEFAULT;

   initprs.rxTriggerEnable = 0;
   initprs.txTriggerEnable = 0;
   initprs.prsTriggerChannel = usartPrsTriggerCh0;

   USART_InitPrsTrigger(USART0, &initprs);
   // [USART_InitPrsTrigger]$

}

//================================================================================
// USART1_enter_DefaultMode_from_RESET
//================================================================================
extern void USART1_enter_DefaultMode_from_RESET(void) {

   // $[USART_InitAsync]
   // [USART_InitAsync]$

   // $[USART_InitSync]
   // [USART_InitSync]$

   // $[USART_InitPrsTrigger]
   // [USART_InitPrsTrigger]$

}

//================================================================================
// LEUART0_enter_DefaultMode_from_RESET
//================================================================================
extern void LEUART0_enter_DefaultMode_from_RESET(void) {

   // $[LEUART0 initialization]
   LEUART_Init_TypeDef initleuart = LEUART_INIT_DEFAULT;

   initleuart.enable = leuartEnable;
   initleuart.baudrate = 9600;
   initleuart.databits = leuartDatabits8;
   initleuart.parity = leuartNoParity;
   initleuart.stopbits = leuartStopbits1;
   LEUART_Init(LEUART0, &initleuart);

   /* Configuring non-standard properties */
   LEUART_TxDmaInEM2Enable(LEUART0, 0);
   LEUART_RxDmaInEM2Enable(LEUART0, 0);

   // [LEUART0 initialization]$

}

//================================================================================
// VCMP_enter_DefaultMode_from_RESET
//================================================================================
extern void VCMP_enter_DefaultMode_from_RESET(void) {

   // $[VCMP_Init]
   // [VCMP_Init]$

}

//================================================================================
// WDOG_enter_DefaultMode_from_RESET
//================================================================================
extern void WDOG_enter_DefaultMode_from_RESET(void) {

   // $[CMU_ClockEnable]
   // [CMU_ClockEnable]$

   // $[CMU_OscillatorEnable]
   // [CMU_OscillatorEnable]$

   // $[WDOG_Init]
   // [WDOG_Init]$

}

//================================================================================
// I2C0_enter_DefaultMode_from_RESET
//================================================================================
extern void I2C0_enter_DefaultMode_from_RESET(void) {

   // $[I2C0 initialization]
   I2C_Init_TypeDef init = I2C_INIT_DEFAULT;

   init.enable = 1;
   init.master = 1;
   init.freq = I2C_FREQ_STANDARD_MAX;
   init.clhr = i2cClockHLRStandard;
   I2C_Init(I2C0, &init);
   // [I2C0 initialization]$

}

//================================================================================
// TIMER0_enter_DefaultMode_from_RESET
//================================================================================
extern void TIMER0_enter_DefaultMode_from_RESET(void) {

   // $[TIMER0 initialization]
   // [TIMER0 initialization]$

   // $[TIMER0 CC0 init]
   // [TIMER0 CC0 init]$

   // $[TIMER0 CC1 init]
   // [TIMER0 CC1 init]$

   // $[TIMER0 CC2 init]
   // [TIMER0 CC2 init]$

   // $[TIMER0 DTI init]
   // [TIMER0 DTI init]$

}

//================================================================================
// TIMER1_enter_DefaultMode_from_RESET
//================================================================================
extern void TIMER1_enter_DefaultMode_from_RESET(void) {

   // $[TIMER1 initialization]
   // [TIMER1 initialization]$

   // $[TIMER1 CC0 init]
   // [TIMER1 CC0 init]$

   // $[TIMER1 CC1 init]
   // [TIMER1 CC1 init]$

   // $[TIMER1 CC2 init]
   // [TIMER1 CC2 init]$

}

//================================================================================
// PCNT0_enter_DefaultMode_from_RESET
//================================================================================
extern void PCNT0_enter_DefaultMode_from_RESET(void) {

   // $[PCNT0 initialization]
   // [PCNT0 initialization]$

}

//================================================================================
// PRS_enter_DefaultMode_from_RESET
//================================================================================
extern void PRS_enter_DefaultMode_from_RESET(void) {

   // $[PRS initialization]
   // [PRS initialization]$

}

//================================================================================
// PORTIO_enter_DefaultMode_from_RESET
//================================================================================
extern void PORTIO_enter_DefaultMode_from_RESET(void) {

   // $[Route Configuration]

   /* Module I2C0 is configured to location 6 */
   I2C0->ROUTE = (I2C0->ROUTE & ~_I2C_ROUTE_LOCATION_MASK)
         | I2C_ROUTE_LOCATION_LOC6;

   /* Enable signals SCL, SDA */
   I2C0->ROUTE |= I2C_ROUTE_SCLPEN | I2C_ROUTE_SDAPEN;

   /* Module LEUART0 is configured to location 5 */
   LEUART0->ROUTE = (LEUART0->ROUTE & ~_LEUART_ROUTE_LOCATION_MASK)
         | LEUART_ROUTE_LOCATION_LOC5;

   /* Enable signals RX, TX */
   LEUART0->ROUTE |= LEUART_ROUTE_RXPEN | LEUART_ROUTE_TXPEN;

   /* Enable signals RX, TX */
   USART0->ROUTE |= USART_ROUTE_RXPEN | USART_ROUTE_TXPEN;
   // [Route Configuration]$

   // $[Port A Configuration]

   /* Pin PA0 is configured to Input enabled */
   GPIO->P[0].MODEL = (GPIO->P[0].MODEL & ~_GPIO_P_MODEL_MODE0_MASK)
         | GPIO_P_MODEL_MODE0_INPUT;

   /* Pin PA1 is configured to Input enabled */
   GPIO->P[0].MODEL = (GPIO->P[0].MODEL & ~_GPIO_P_MODEL_MODE1_MASK)
         | GPIO_P_MODEL_MODE1_INPUT;
   // [Port A Configuration]$

   // $[Port B Configuration]
   // [Port B Configuration]$

   // $[Port C Configuration]

   /* Pin PC4 is configured to Input enabled */
   GPIO->P[2].MODEL = (GPIO->P[2].MODEL & ~_GPIO_P_MODEL_MODE4_MASK)
         | GPIO_P_MODEL_MODE4_INPUT;

   /* Pin PC9 is configured to Input enabled */
   GPIO->P[2].MODEH = (GPIO->P[2].MODEH & ~_GPIO_P_MODEH_MODE9_MASK)
         | GPIO_P_MODEH_MODE9_INPUT;

   /* Pin PC14 is configured to Push-pull */
   GPIO->P[2].MODEH = (GPIO->P[2].MODEH & ~_GPIO_P_MODEH_MODE14_MASK)
         | GPIO_P_MODEH_MODE14_PUSHPULL;

   /* Pin PC15 is configured to Input enabled */
   GPIO->P[2].MODEH = (GPIO->P[2].MODEH & ~_GPIO_P_MODEH_MODE15_MASK)
         | GPIO_P_MODEH_MODE15_INPUT;
   // [Port C Configuration]$

   // $[Port D Configuration]
   // [Port D Configuration]$

   // $[Port E Configuration]

   /* Pin PE10 is configured to Push-pull */
   GPIO->P[4].MODEH = (GPIO->P[4].MODEH & ~_GPIO_P_MODEH_MODE10_MASK)
         | GPIO_P_MODEH_MODE10_PUSHPULL;

   /* Pin PE11 is configured to Input enabled */
   GPIO->P[4].MODEH = (GPIO->P[4].MODEH & ~_GPIO_P_MODEH_MODE11_MASK)
         | GPIO_P_MODEH_MODE11_INPUT;

   /* Pin PE12 is configured to Open-drain with pull-up and filter */
   GPIO->P[4].MODEH = (GPIO->P[4].MODEH & ~_GPIO_P_MODEH_MODE12_MASK)
         | GPIO_P_MODEH_MODE12_WIREDANDPULLUPFILTER;

   /* Pin PE13 is configured to Open-drain with pull-up and filter */
   GPIO->P[4].MODEH = (GPIO->P[4].MODEH & ~_GPIO_P_MODEH_MODE13_MASK)
         | GPIO_P_MODEH_MODE13_WIREDANDPULLUPFILTER;
   // [Port E Configuration]$

   // $[Port F Configuration]

   /* Pin PF2 is configured to Input enabled */
   GPIO->P[5].MODEL = (GPIO->P[5].MODEL & ~_GPIO_P_MODEL_MODE2_MASK)
         | GPIO_P_MODEL_MODE2_INPUT;
   // [Port F Configuration]$

}

